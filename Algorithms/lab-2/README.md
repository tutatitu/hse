# Вторая лабораторная работа по алгоритмам
## Контест
Логин: lartsev200@yandex.ru

[Решение](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/src/contest.cpp).

![image](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/data/result.png)
## Информация о проекте
Лабораторная выполнена на с++20, компилятор g++ 13.1.0.  
Запуск:
```powershell
cd "\lab-2\" ; #вместо ... указываем путь до папки с файлом
if ($?) { g++ main.cpp -o main } ;
if ($?) { .\main }
```
# Визуализация и анализ
## Подготовка
Приведу обычный и логарифмический графики:
![image](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/data/prepare.png)
![image](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/data/prepare-log.png)
### Алгоритм перебора (Brute Force):
Время подготовки: `О(1)`

Этот метод не требует предварительной подготовки данных, поскольку он просто перебирает все прямоугольники непосредственно при каждом запросе.

Поэтому время подготовки остается постоянным, независимо от размера данных.
### Алгоритм на карте (Compressed Map):
Время подготовки: `O(N^3)`

Этот метод требует сжатия координат и построения карты, что занимает дополнительное время. Время подготовки будет расти кубически относительно количества прямоугольников N, это хорошо видно на графике.
### Алгоритм на дереве (Segment Tree):
Время подготовки: `O(N log N)`

Для этого метода также требуется сжатие координат и построение персистентного дерева отрезков. Время подготовки будет расти логарифмически относительно количества прямоугольников N.

## Выполнение
Снова приведу два типа графиков:
![image](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/data/run.png)
![image](https://github.com/tutatitu/hse/blob/main/Algorithms/lab-2/data/run-log.png)

### Алгоритм перебора (Brute Force):
Время выпонения: `О(N)`

Время выполнения растет быстро с увеличением количества прямоугольников. Это происходит потому, что для каждого запроса приходится перебирать все прямоугольники.
### Алгоритм на карте (Compressed Map):
Время выпонения: `О(log N)`

Время выполнения растет, но не так быстро, как у алгоритма перебора. Это связано с тем, что подготовка карты (сжатие координат и построение) требует дополнительного времени, но затем поиск осуществляется более эффективно.

Для 2000 прямоугольников время выполнения составляет около 812 200, что все еще значительно меньше, чем у алгоритма перебора.
### Алгоритм на дереве (Segment Tree):
Время выпонения: `О(log N)`

Время выполнения также растет с увеличением количества прямоугольников, но не так быстро, как у алгоритма перебора.

Для 2000 прямоугольников время выполнения составляет около 1 319 000, что также меньше, чем у алгоритма перебора, но больше, чем у алгоритма на карте.
## Выводы
Алгоритм перебора имеет самое низкое время подготовки, так как он не требует предварительной обработки данных. Для небольших объемов данных алгоритм может быть приемлемым, но с ростом количества прямоугольников его производительность снижается.

Алгоритм на карте имеет самое высокое время подготовки из-за необходимости выполнения сжатия координат и построения карты, что занимает кубическое время относительно количества прямоугольников. Алгоритм показывает более стабильное время выполнения по сравнению с алгоритмом перебора на больших объемах данных.

Алгоритм на дереве имеет более высокое время подготовки, чем алгоритм перебора, но оно все равно остается довольно эффективным благодаря логарифмической сложности. Алгоритм также является эффективным для больших объемов данных, но его время выполнения немного больше, чем у алгоритма на карте, и меньше, чем у алгоритма перебора.
